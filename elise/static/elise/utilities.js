
// Fisher-Yates shuffle algorithm https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
function shuffle(array) {
	var m = array.length, t, i;

	// While there remain elements to shuffle…
	while (m) {

		// Pick a remaining element…
		i = Math.floor(Math.random() * m--);

		// And swap it with the current element.
		t = array[m];
		array[m] = array[i];
		array[i] = t;
	}

	return array;
}

// functions for derangement in randomization procudure 
function derangementNumber(n) {
    if(n == 0) {
        return 1;
    }
    var factorial = 1;
    while(n) {
        factorial *= n--;
    }
    return Math.floor(factorial / Math.E);
}

function derange(array) {
    array = array.slice();
    var mark = array.map(function() { return false; });
    for(var i = array.length - 1, u = array.length - 1; u > 0; i--) {
        if(!mark[i]) {
            var unmarked = mark.map(function(_, i) { return i; })
                .filter(function(j) { return !mark[j] && j < i; });
            var j = unmarked[Math.floor(Math.random() * unmarked.length)];

            var tmp = array[j];
            array[j] = array[i];
            array[i] = tmp;

            // this introduces the unbiased random characteristic
            if(Math.random() < u * derangementNumber(u - 1) /  derangementNumber(u + 1)) {
                mark[j] = true;
                u--;
            }
            u--;
        }
    }
    return array;
}

function doubleDerangement(array) {
	var arrayDeranged1 = derange(array);
	var works = 0; 
	do {
		var arrayDeranged2 = derange(array);
		works = 1
		for (f=0; f<array.length; f++){
			if (arrayDeranged1[f]==arrayDeranged2[f]){
				works = 0
			};
		};
	}
	while(works == 0);
	return [arrayDeranged1, arrayDeranged2];
}

function tripleDerangement(array) {
	var arrayDeranged2 = doubleDerangement(array);
	var arrayDerangeda = arrayDeranged2[0];
	var arrayDerangedb = arrayDeranged2[1];
	var works = 0; 
	do {
		var arrayDeranged3 = derange(array);
		works = 1
		for (f=0; f<array.length; f++){
			if (arrayDeranged3[f]==arrayDerangeda[f]){
				works = 0
			} else if (arrayDeranged3[f]==arrayDerangedb[f]){
				works = 0
			};
		};
	}
	while(works == 0);
	return [arrayDerangeda, arrayDerangedb, arrayDeranged3];
}

// Global for storing experiment sequence that is produced after reading in the experiment sequence
var trialData = " ";

// Takes info from CSV file and obtains experiment sequence that is encoded and returned as a 2D list
function processData(allText) {

	// Regex to split CSV format into 2D matrix 
	var allTextLines = allText.split(/\r\n|\n/);

	// Headers for each column that are stored as the first row in the matrix
	var headers = allTextLines[0].split(',');

	// Removes any blank headers 
	while (headers[headers.length - 1] == "") {
		headers.pop();
	}

	// Stores experiment lines 
	var lines = [];

	// Iterates through rows, each of which stores a list of experiment codes
	for (var i = 0; i < allTextLines.length; i++) {

		// splits comma separated experiment codes for current row
		var data = allTextLines[i].split(',');

		// Removes empty columns
		while (data[data.length - 1] == "") {
			data.pop();
		}

		// Checks to see that removing empty columns did not lead to an uneven row length. If this happens,
		// the CSV file is not properly formatted
		if (data.length == headers.length) {

			// Array storing the specific experiment codes from each string 
			var tarr = [];

			// Iterates through the experiment sequence for the current row
			for (var j = 0; j < data.length; j++) {

				// The experiment codes are stored in the format 'experimentnumberplurality' i.e. 12s means the 12th 
				// monster singular will be the stimulus
				var curr = data[j]

				// Pushes a tuple storing the monster number and plurality by splitting the string 
				tarr.push([curr.substring(0, curr.length - 1), curr.substring(curr.length - 1)]);
			}

			// Pushes to matrix
			lines.push(tarr);
		}
	}

	// Sets trialData global to the matrix generated by the method
	trialData = lines;
}

var EMlist = " ";

// Takes info from CSV file and obtains experiment sequence that is encoded and returned as a 2D list
function processList(allText) {

	// Regex to split CSV format into 2D matrix 
	var allTextLines = allText.split(/\r\n|\n|\t\n|\t\t\t\t\t/);

	// Headers for each column that are stored as the first row in the matrix
	var headers = allTextLines[0].split('\t');
	// Removes any blank headers 
	while (headers[headers.length - 1] == "") {
		headers.pop();
	}

	// Stores experiment lines 
	var round1 = [];
	var round2 = [];
	var round3 = [];

	// Iterates through rows, each of which stores a list of experiment codes
	for (var i = 0; i < allTextLines.length; i++) {

		// splits comma separated experiment codes for current row
		var data = allTextLines[i].split('\t');

		// Removes empty columns
		while (data[data.length - 1] == "") {
			data.pop();
		}

		// Checks to see that removing empty columns did not lead to an uneven row length. If this happens,
		// the CSV file is not properly formatted
		if (data.length == headers.length && i < 28) {

			// Array storing the specific experiment codes from each string 
			// Iterates through the experiment sequence for the current row
			for (var j = 0; j < data.length; j++) {

				// The experiment codes are stored in the format 'experimentnumberplurality' i.e. 12s means the 12th 
				// monster singular will be the stimulus
				var curr = data[j]
				// Pushes a tuple storing the monster number and plurality by splitting the string 
				if (j == 0) {
					round1.push([curr.substring(0, curr.length - 2), curr.substring(curr.length - 2, curr.length - 1), curr.substring(curr.length - 1)]);
				} else if (j == 1) {
					round2.push([curr.substring(0, curr.length - 2), curr.substring(curr.length - 2, curr.length - 1), curr.substring(curr.length - 1)]);
				} else if (j == 2) {
					round3.push([curr.substring(0, curr.length - 2), curr.substring(curr.length - 2, curr.length - 1), curr.substring(curr.length - 1)]);
				}
			}
		}
	}
	EMlist = [round1, round2, round3];
	// Sets trialData global to the matrix generated by the method
	console.log(EMlist);
}

// Given an image number, outputs a string with the file name for that image
function imageFileName(imageNumber) {

	// Small images
	if (imageNumber < 12) {
		return "l" + (imageNumber + 1) + ".png";
	}

	// Large images
	else {
		return "h" + (imageNumber - 12 + 1) + ".png";
	}
}

function getPrompt(sound) {
	var underscorePrompt = soundToPrompt[sound];
	var prompt = underscorePrompt.replace("_", " ");
	return prompt;
}

// Given the determiner number, a boolean with true-> small, false-> big, a monster number and a boolean 
// with true->singular false->plural, outputs the file name for the associated sound file
function soundFileName(determiner, isSmall, monsterNumber, isSingular) {

	// Encodes determiner number
	var det = "det" + determiner + "_";
	var size;

	// Encodes size based on boolean value
	if (isSmall) {
		size = "small";
	}
	else {
		size = "big";
		monsterNumber = monsterNumber - 12;
	}
	var plurality;

	// Encodes plurality based on boolean value
	if (isSingular) {
		plurality = "s";
	}
	else {
		plurality = "p";
	}

	// Concatenates all encodings as they appear in the file name
	return det + size + monsterNumber + plurality + ".wav";
}

// dictionaries for big and small file names
var big = {};
var small = {};

function constructValues() {

	// Shuffles between the 4 determiners and randomly assigns them to the small and big plural and singular forms
	var dets = [1, 2, 3, 4]
	shuffle(dets)
	detSmallSing = dets[0]
	detSmallPlur = dets[1]
	detLargeSing = dets[2]
	detLargePlur = dets[3]

	// Constructs file dictionary for small monsters
	for (var i = 0; i < 12; i++) {
		// Retrieves image file
		var img = imageFileName(i)

		// Retrieves sounds for plural and singular with selected determiner
		var singSound = soundFileName(detSmallSing, true, i, true)
		var plurSound = soundFileName(detSmallPlur, true, i, false)
		// Adds current monster to dictionary in the structure 
		// [image file name, sub-dictionary storing plural sound file with key p and singular sound file with key s, sub-dictionary storing plural prompt string with key p and singular prompt string with key s]
		small[i] = [img, { "p": plurSound, "s": singSound }, { "p": soundToPrompt[plurSound], "s": soundToPrompt[singSound] }]
	}
	// Constructs file dictionary for large monsters
	for (var i = 12; i < 30; i++) {
		// Retrieves image file
		var img = imageFileName(i)

		// Retrieves sounds for plural and singular with selected determiner
		singSound = soundFileName(detLargeSing, false, i, true)
		plurSound = soundFileName(detLargePlur, false, i, false)
		
		// Adds current monster to dictionary in the structure 
		// [image file name, sub-dictionary storing plural sound file with key p and singular sound file with key s, sub-dictionary storing plural prompt string with key p and singular prompt string with key s]
		big[i - 12] = [img, { "p": plurSound, "s": singSound }, { "p": soundToPrompt[plurSound], "s": soundToPrompt[singSound] }]
	}
}



// Global storing the current instruction within the trial
var currentInstructionCounter = 0

// Plays the next instruction in the sequence for the trial
function playNextInstruction() {

	// Stores timeline object for the instruction 
	var instruction;

	// Checks for comp or prod trial, generates the instruction message timeline object for the appropriate trial
	if (comp) {
		if (compMessageSequence[currentInstructionCounter] == null) {
			instruction = {
				// Displays message with no user response
				type: 'image-keyboard-response',
				stimulus: '/static/elise/img/images/blank.png',
				choices: jsPsych.NO_KEYS,
				trial_duration: 0
			}
		}
		else {
			instruction = {
				type: 'instructions',
				pages: ["<div style='white-space: pre-wrap; padding-left:20%; padding-right:20%'>" + compMessageSequence[currentInstructionCounter] + "</div>"]
				,
				show_clickable_nav: true,
				allow_backward:false,
				key_forward: 'Enter',
				button_label_next: 'Continue'
			}
		}
	}
	else {
		if (prodMessageSequence[currentInstructionCounter] == null) {
			instruction = {
				type: 'image-keyboard-response',
				stimulus: '/static/elise/img/images/blank.png',
				choices: jsPsych.NO_KEYS,
				trial_duration: 0
			}
		}
		else {
			instruction = {
				type: 'instructions',
				pages: ["<div style='white-space: pre-wrap; padding-left:20%; padding-right:20%'>" + prodMessageSequence[currentInstructionCounter] + "</div>"]
				,
				show_clickable_nav: true,
				allow_backward:false,
				key_forward: 'Enter',
				button_label_next: 'Continue'
			}
		}
	}
	// Increments counter so next instruction is selected on the next call
	currentInstructionCounter++;
	return instruction;
}

// Function used to pause the trial when required
function sleep(milliseconds) {
	const date = Date.now();
	let currentDate = null;
	do {
		currentDate = Date.now();
	} while (currentDate - date < milliseconds);
}
// Function for grabbing parameters from URL
function getParamFromURL( name ) {
	name = name.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");
	var regexS = "[\?&]"+name+"=([^&#]*)";
	var regex = new RegExp( regexS );
	var results = regex.exec( window.location.href );
	if( results == null )
		return "";
	else
		return results[1];
}


// Files storing message sequence globals that will be assigned within the makeExp function. They are assigned within this function because it won't be called until the files have already been processed 
var prodMessageSequence;
var compMessageSequence;

var quarter_message = "You are now through 1/4th of this test. Keep it up!";
var half_message = "You are now through 2/4th of this test. Keep it up!";
var threequarter_message = "You are now through 3/4th of this test. Keep it up!";

// Generates an experiment timeline 
function makeExp() {
	
	// Sequences for messages. 
	prodMessageSequence = [openingmessage, audiocheckmessage1, audiocheckmessage2, audiocheckmessage, audiocheckmessage3, passivemessage1
		, passivemessage, passivemessage2, activeprodmessage1, activeprodmessage, activeprodmessage2
		, passivemessage, activeprodmessage, passivemessage, activeprodmessage, audiocheckmessage
		, passivemessage, activeprodmessage, passivemessage, activeprodmessage, passivemessage, activeprodmessage, audiocheckmessage
		, passivemessage, activeprodmessage, passivemessage, activeprodmessage, passivemessage, activeprodmessage, audiocheckmessage
		, passivemessage, activeprodmessage, passivemessage, activeprodmessage, passivemessage, activeprodmessage, audiocheckmessage
		, forcedchoicemessage2pic, audiocheckmessage
		, forcedchoicemessage4pic, quarter_message, audiocheckmessage, FC4message, half_message, audiocheckmessage, FC4message
		, threequarter_message, audiocheckmessage, FC4message, audiocheckmessage
		, grammaticalityjudgment, quarter_message, audiocheckmessage, grammaticalityjudgmentmessage, half_message, audiocheckmessage
		, grammaticalityjudgmentmessage, threequarter_message, audiocheckmessage, grammaticalityjudgmentmessage, audiocheckmessage
		, prodtest1, prodtest2, quarter_message, audiocheckmessage, prodtestmessage
		, half_message, audiocheckmessage, prodtestmessage, threequarter_message, audiocheckmessage, prodtestmessage
		, audiocheckmessage, surveymessage, endmessagep]
	for (var i = 0; i < prodMessageSequence.length; i++) {
		if (prodMessageSequence[i] == ""){
		prodMessageSequence[i] = null;
		}
	}
	compMessageSequence = [openingmessage, audiocheckmessage1, audiocheckmessage2, audiocheckmessage, audiocheckmessage3, passivemessage1
		, passivemessage, passivemessage2, activecompmessage1bcd, activecompmessage11, activecompmessage, activecompmessage2
		, passivemessage, activecompmessage, passivemessage, activecompmessage, audiocheckmessage
		, passivemessage, activecompmessage, passivemessage, activecompmessage, passivemessage, activecompmessage, audiocheckmessage
		, passivemessage, activecompmessage, passivemessage, activecompmessage, passivemessage, activecompmessage, audiocheckmessage
		, passivemessage, activecompmessage, passivemessage, activecompmessage, passivemessage, activecompmessage, audiocheckmessage
		, forcedchoicemessage2pic, audiocheckmessage
		, forcedchoicemessage4pic, quarter_message, audiocheckmessage, FC4message, half_message, audiocheckmessage, FC4message
		, threequarter_message, audiocheckmessage, FC4message, audiocheckmessage
		, grammaticalityjudgment, quarter_message, audiocheckmessage, grammaticalityjudgmentmessage, half_message, audiocheckmessage
		, grammaticalityjudgmentmessage, threequarter_message, audiocheckmessage, grammaticalityjudgmentmessage, audiocheckmessage
		, prodtest1, prodtest2, quarter_message, audiocheckmessage, prodtestmessage
		, half_message, audiocheckmessage, prodtestmessage, threequarter_message, audiocheckmessage, prodtestmessage
		, audiocheckmessage, surveymessage, endmessagec]
	for (var i = 1; i < compMessageSequence.length; i++) {
		if (compMessageSequence[i] == ""){
		compMessageSequence[i] = null;
		}
	}
	
	// Obtains value 'cond' from URL which encodes whether the experiment will be production 'p'/NA or comprehension 'c'
	// Obtains value 'subjectnr' from URL
	// example: http://localhost:8000/elise6.html?subjectnr=11111&?cond=c
	// example: https://talk.psych.wisc.edu/test/elise7/?subjectnr=11113&?cond=p
	const queryString = window.location.search;
	const urlParams = new URLSearchParams(queryString);
	cond = getParamFromURL('cond');
	subjectnr =getParamFromURL('subjectnr');
	if (cond == 'c') {
		comp = true;
	} else {
		comp = false;
		cond = 'p';
	}


	// Constructs dictionary of appropriate sound and image files
	constructValues();

	// Obtains big and small values from the dictionary storing their data
	var bigValues = Object.values(big);
	var smallValues = Object.values(small);
	
	// Obtains the specific image and sound files and prompt text for each of the big and small data files
	var bigImages = [];
	for (var i = 0; i < bigValues.length; i++) {
		bigImages.push(bigValues[i][0]);
	}
	var smallImages = [];
	for (var i = 0; i < smallValues.length; i++) {
		smallImages.push(smallValues[i][0]);
	}
	var bigSounds = [];
	for (var i = 0; i < bigValues.length; i++) {
		bigSounds.push(bigValues[i][1]);
	}
	var smallSounds = [];
	for (var i = 0; i < smallValues.length; i++) {
		smallSounds.push(smallValues[i][1]);
	}

	// Shuffles the big and small images and sounds
	shuffle(bigImages);
	shuffle(smallImages);
	shuffle(bigSounds);
	shuffle(smallSounds);
	
	// Concatenates images such that 0-17 are big, 18-29 small
	var allImages = bigImages.concat(smallImages);
	var allSounds = bigSounds.concat(smallSounds);


	// Adds participant monster selections to data array
	for(var i = 0; i < 12;i++){
		participant_data_array.push([i,allImages[i],allSounds[i]["s"],allSounds[i]["p"],"big","training"])
	}
	for(var i = 12; i < 18;i++){
		participant_data_array.push([i,allImages[i],allSounds[i]["s"],allSounds[i]["p"],"big","testing"])
	}
	// Adds participant monster selections to data array
	for(var i = 18; i < 24;i++){
		participant_data_array.push([i,allImages[i],allSounds[i]["s"],allSounds[i]["p"],"small","training"])
	}
	for(var i = 24; i < 30;i++){
		participant_data_array.push([i,allImages[i],allSounds[i]["s"],allSounds[i]["p"],"small","testing"])
	}

	console.log("participant data array")
	console.log(participant_data_array)

	// Shuffles the row sequences in trial data 
	shuffle(trialData);

	// Current row
	curr = trialData[0];
	// Stores experiment block for this row
	block = [];

	// Shuffles the row itself
	shuffle(curr);


	// Stores experiment timeline object
	var experiments = [];

	var preload = {
    	type: 'preload',
    	auto_preload: true 
	}

	experiments.push(preload);

	experiments.push({
  		type: 'fullscreen',
  		fullscreen_mode: true
		});

	var data_header = ["subjectnr", "condition", "trialnr", "trial_type", "target_aliennr", "target_sound", "neighborhood", "subneighborhood", "target_plural", "target_image", "RT", "correct", "key_pressed", "correct_key", "typed_response", "target_response", "trial_subtype", "match_or_grammatical", "left_top_or_foil_image", "right_top_image", "left_bottom_image", "right_bottom_image", "timestamp", "break_time"]
	total_data_array.push(data_header)

	experiments.push(playNextInstruction())
	experiments.push(playNextInstruction())
	experiments.push(audio_check_trial_1("/static/elise/sound/airplane_w.wav"))
	experiments.push(playNextInstruction())
	experiments.push(playNextInstruction())
	experiments.push(audio_check_trial_2("/static/elise/sound/candle_w.wav", "candle"))
	experiments.push(playNextInstruction())
	experiments.push(playNextInstruction())
	experiments.push(playNextInstruction())


	//[first 6 passive trials]
	// Iterates through the row, obtaining trial objects
	for (var j = 0; j < curr.length; j++) {

		// Obtains monster number and plurality from the parsed data
		var monsterIndex = parseInt(curr[j][0]);
		var singOrPlural = curr[j][1];
		var isPlural = false;

		if (singOrPlural == 'p'){
			isPlural = true;
		}




		// Calls functions to obtain trial objects and pushes them to the timeline
		// this part of the experiment contains passive comprehension trials
		experiments.push(passive_comprehension_trial("/static/elise/img/images/" + allImages[monsterIndex],
			"/static/elise/sound/combinedsounds/" + allSounds[monsterIndex][singOrPlural], getPrompt(allSounds[monsterIndex][singOrPlural]),isPlural, monsterIndex));

	}

	experiments.push(playNextInstruction())

	if (comp) {
		experiments.push(playNextInstruction())
		experiments.push(active_comprehension_trial("/static/elise/img/images/pear.png", "/static/elise/img/images/apple.png", false, "/static/elise/sound/apple_w.wav", "apple", false, "-"))
		experiments.push(active_comprehension_trial("/static/elise/img/images/apple.png", "/static/elise/img/images/apple.png", true, "/static/elise/sound/apple_w.wav", "apple", false, "-"))
	}
	experiments.push(playNextInstruction())
	experiments.push(playNextInstruction())


	// Current row
	curr = trialData[0];

	// Shuffles the row sequence once again
	shuffle(curr);

	// Creates a list of 3 random indexes to decide which of the active trials will be mismatches
	// These will only be used for active comprehension blocks
	// The third mismatchtrial chosen will be a plurality mismatch instead of a noun mismatch
	var index_list = []
	for (var k = 0; k < 6; k++) {
		index_list.push(k);
	}
	var mismatches = []
	var pluralMismatch = []
	var randind = 0;
	var randchoice = 0;
	randind = (Math.floor(Math.random() * 6))
	randchoice = (index_list.splice(randind, 1)[0])
	mismatches.push(randchoice);
	randind = (Math.floor(Math.random() * 5))
	randchoice = (index_list.splice(randind, 1)[0])
	mismatches.push(randchoice);
	randind = (Math.floor(Math.random() * 4))
	randchoice = (index_list.splice(randind, 1)[0])
	pluralMismatch.push(randchoice);
	mismatches = new Set(mismatches);
	pluralMismatch = new Set(pluralMismatch);
	// Comprehension trial
	if (comp) {

		// Same process as passive trial but generates active comprehension trial 
		for (var j = 0; j < curr.length; j++) {
			var monsterIndex = parseInt(curr[j][0]);
			var singOrPlural = curr[j][1];
			var isPlural = false;
			var firstImage = allImages[monsterIndex];
			var secondImage = allImages[monsterIndex];
			var correct = true;

			// If target audio is plural, set images as plural
			if (singOrPlural == 'p'){
				isPlural = true;
				firstImage = firstImage.substring(0,firstImage.length-4)+"p.png";
				secondImage = secondImage.substring(0,secondImage.length-4)+"p.png";
			}

			// This is where a mismatched image will be chosen for 3 random indices 
			// It's chosen 0-11 if that's what the monster itself is (big neighborhood, trained)
			// It's chosen 18-23 if that's what the monster itself is (small neighborhood, trained)
			// For the single pluralMismatch it's simply the monster itself with opposite plurality
			if (mismatches.has(j)) {
				correct = false;
				if (monsterIndex < 12) {
					randMonster = Math.floor(Math.random() * 12);
					if (randMonster == monsterIndex && randMonster < 11) {
						randMonster++;
					}
					else if (randMonster == monsterIndex) {
						randMonster = 0;
					}
				} else {
					randMonster = Math.floor(Math.random() * 6 + 18);
					if (randMonster == monsterIndex && randMonster < 23) {
						randMonster++;
					}
					else if (randMonster == monsterIndex) {
						randMonster = 18;
					}
				}
				firstImage = allImages[randMonster];
				if(isPlural){
					firstImage = firstImage.substring(0,firstImage.length-4)+"p.png";
				}
			} else if (pluralMismatch.has(j)){
				correct = false;
				if(isPlural){
					firstImage = allImages[monsterIndex];
				} else{
					firstImage = firstImage.substring(0,firstImage.length-4)+"p.png";
				}
			}

			experiments.push(active_comprehension_trial(
				"/static/elise/img/images/" + firstImage,
				"/static/elise/img/images/" + secondImage,
				correct,
				"/static/elise/sound/combinedsounds/" + allSounds[monsterIndex][singOrPlural],
				getPrompt(allSounds[monsterIndex][singOrPlural]),isPlural,monsterIndex));

		}
	}
	// Production trial 
	else {
		for (var j = 0; j < curr.length; j++) {
			var monsterIndex = parseInt(curr[j][0]);
			var singOrPlural = curr[j][1];
			var isPlural = false;

			if (singOrPlural == 'p'){
				isPlural = true;
			}

			experiments.push(active_production_trial("/static/elise/img/images/" + allImages[monsterIndex],
				"/static/elise/sound/combinedsounds/" + allSounds[monsterIndex][singOrPlural], getPrompt(allSounds[monsterIndex][singOrPlural]),isPlural,monsterIndex));
		}
	}


	// Iterates through the rows in the trial data matrix
	// Starts at index 1 to account for initial trials that have already been added

	experiments.push(playNextInstruction())


	for (var i = 1; i < trialData.length; i++) {
		// Current row
		curr = trialData[i];

		// Stores experiment block for this row
		block = [];

		// Shuffles the row itself
		shuffle(curr);

		//Passivemessage
		experiments.push(playNextInstruction())

		//[round of 6 passive trials]
		// Iterates through the row, obtaining trial objects
		for (var j = 0; j < curr.length; j++) {

			// Obtains monster number and plurality from the parsed data
			var monsterIndex = parseInt(curr[j][0]);
			var singOrPlural = curr[j][1];

			var isPlural = false;

			if (singOrPlural == 'p'){
				isPlural = true;
			}

			// Calls functions to obtain trial objects and pushes them to the timeline
			// this part of the experiment contains passive comprehension trials
			experiments.push(passive_comprehension_trial("/static/elise/img/images/" + allImages[monsterIndex],
				"/static/elise/sound/combinedsounds/" + allSounds[monsterIndex][singOrPlural], getPrompt(allSounds[monsterIndex][singOrPlural]),isPlural, monsterIndex));
		}


		// Shuffles the row sequence once again
		shuffle(curr);

		// Creates a list of 3 random indexes to decide which of the active trials will be mismatches
		// These will only be used for active comprehension blocks
		index_list = []
		for (var j = 0; j < 6; j++) {
			index_list.push(j);
		}
		let mismatches = []
		let randind = (Math.floor(Math.random() * 6))
		let randchoice = (index_list.splice(randind, 1)[0])
		mismatches.push(randchoice);
		randind = (Math.floor(Math.random() * 5))
		randchoice = (index_list.splice(randind, 1)[0])
		mismatches.push(randchoice);
		randind = (Math.floor(Math.random() * 4))
		randchoice = (index_list.splice(randind, 1)[0])
		mismatches.push(randchoice);
		mismatches = new Set(mismatches);

		//Activecompmessage		activeprodmessage
		experiments.push(playNextInstruction())

		//[round of 6 active comp trials]	[round of 6 active prod trials]
		// Comprehension trial
		if (comp) {

			// Same process as passive trial but generates active comprehension trial 
			for (var j = 0; j < curr.length; j++) {
				var monsterIndex = parseInt(curr[j][0]);
				var singOrPlural = curr[j][1];
				var isPlural = false;
				var firstImage = allImages[monsterIndex];
				var secondImage = allImages[monsterIndex];
				var correct = true;

				// If target audio is plural, set images as plural
				if (singOrPlural == 'p'){
					isPlural = true;
					firstImage = firstImage.substring(0,firstImage.length-4)+"p.png";
					secondImage = secondImage.substring(0,secondImage.length-4)+"p.png";
				}

				// This is where a mismatched image will be chosen for 3 random indices 
				// It's chosen 0-11 if that's what the monster itself is (big neighborhood, trained)
				// It's chosen 18-23 if that's what the monster itself is (small neighborhood, trained)
				// For the single pluralMismatch it's simply the monster itself with opposite plurality
				if (mismatches.has(j)) {
					correct = false;
					if (monsterIndex < 12) {
						randMonster = Math.floor(Math.random() * 12);
						if (randMonster == monsterIndex && randMonster < 11) {
							randMonster++;
						}
						else if (randMonster == monsterIndex) {
							randMonster = 0;
						}
					} else {
						randMonster = Math.floor(Math.random() * 6 + 18);
						if (randMonster == monsterIndex && randMonster < 23) {
							randMonster++;
						}
						else if (randMonster == monsterIndex) {
							randMonster = 18;
						}
					}
					firstImage = allImages[randMonster];
					if(isPlural){
						firstImage = firstImage.substring(0,firstImage.length-4)+"p.png";
					}
				} else if (pluralMismatch.has(j)){
					correct = false;
					if(isPlural){
						firstImage = allImages[monsterIndex];
					} else{
						firstImage = firstImage.substring(0,firstImage.length-4)+"p.png";
					}
				}

				experiments.push(active_comprehension_trial(
					"/static/elise/img/images/" + firstImage,
					"/static/elise/img/images/" + secondImage,
					correct,
					"/static/elise/sound/combinedsounds/" + allSounds[monsterIndex][singOrPlural],
					getPrompt(allSounds[monsterIndex][singOrPlural]),isPlural,monsterIndex));
			}

		}
		// Production trial 
		else {
			for (var j = 0; j < curr.length; j++) {
				var monsterIndex = parseInt(curr[j][0]);
				var singOrPlural = curr[j][1];

				var isPlural = false;

				if (singOrPlural == 'p'){
					isPlural = true;
				}

				experiments.push(active_production_trial("/static/elise/img/images/" + allImages[monsterIndex],
					"/static/elise/sound/combinedsounds/" + allSounds[monsterIndex][singOrPlural], getPrompt(allSounds[monsterIndex][singOrPlural]),isPlural,monsterIndex));
			}
		}

		if ((i + 1) % 3 == 0) {
			experiments.push(playNextInstruction())
			if (i == 2) {
				experiments.push(audio_check_trial_2("/static/elise/sound/wallet_w.wav", "wallet"))
			} else if (i == 5) {
				experiments.push(audio_check_trial_2("/static/elise/sound/feather_w.wav", "feather"))
			} else if (i == 8) {
				experiments.push(audio_check_trial_2("/static/elise/sound/onion_w.wav", "onion"))
			} else {
				experiments.push(audio_check_trial_2("/static/elise/sound/towel_w.wav", "towel"))
			}
			
		}
	}

	experiments.push(playNextInstruction())

	// for the 2AFC trials, we need to randomly pick which 3 (of 6) test-only aliens in each neighborhood will be singular in the first round
	// so, we pick 3 alien identifiers for each that will be singular in the first round. 

	index_list_big_pl = []
	for (var j = 12; j < 18; j++) {
		index_list_big_pl.push(j);
	}
	let big_plurals = []
	randind = (Math.floor(Math.random() * 6))
	randchoice = (index_list_big_pl.splice(randind, 1)[0])
	big_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 5))
	randchoice = (index_list_big_pl.splice(randind, 1)[0])
	big_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 4))
	randchoice = (index_list_big_pl.splice(randind, 1)[0])
	big_plurals.push(randchoice);
	big_plurals = new Set(big_plurals);

	index_list_small_pl = []
	for (var j = 24; j < 30; j++) {
		index_list_small_pl.push(j);
	}
	let small_plurals = []
	randind = (Math.floor(Math.random() * 6))
	randchoice = (index_list_small_pl.splice(randind, 1)[0])
	small_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 5))
	randchoice = (index_list_small_pl.splice(randind, 1)[0])
	small_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 4))
	randchoice = (index_list_small_pl.splice(randind, 1)[0])
	small_plurals.push(randchoice);
	small_plurals = new Set(small_plurals);

	// for the second round we also need to pick a foil alien from the other neighborhood
	// to do that, we simply create another shuffled version of available aliens (big/small_test_foil)

	var big_test_foil = [];
	for (var b = 12; b < 18; b++) {
		big_test_foil.push(b);
	}

	var small_test_foil = [];
	for (var s = 24; s < 30; s++) {
		small_test_foil.push(s);
	}	

	shuffle(big_test_foil);
	shuffle(small_test_foil);

	// now, we create both rounds of 2AFC tests
	// for the first round, all we need is an alien and its target plurality
	// for the second round, we also add a foil alien from the other neighborhood

	var round_1_2AFC = [];
	var round_2_2AFC = [];

	for (var k = 0; k < 6; k++){
		var big_alien = 12 + k;
		var small_alien = 24 + k;
		var big_foil = big_test_foil[k];
		var small_foil = small_test_foil[k];
		if (big_plurals.has(big_alien)) {
			round_1_2AFC.push([big_alien, "p"])
			round_2_2AFC.push([big_alien, "s", small_foil])
			
		} else {
			round_1_2AFC.push([big_alien, "s"])
			round_2_2AFC.push([big_alien, "p", small_foil])	
		}
		if (small_plurals.has(small_alien)) {
			round_1_2AFC.push([small_alien, "p"])
			round_2_2AFC.push([small_alien, "s", big_foil])
		} else {
			round_1_2AFC.push([small_alien, "s"])
			round_2_2AFC.push([small_alien, "p", big_foil])	
		}
	}

	// now, we simply shuffle each list and play those trials

	shuffle(round_1_2AFC);
	shuffle(round_2_2AFC);


	var left_right = [true, false];

	for (var i = 0; i < 12; i++) {
		shuffle(left_right);
		var curr_trial = round_1_2AFC[i];
		var monsterIndex = parseInt(curr_trial[0]);
		var singOrPlural = curr_trial[1];
		var isPlural = false;
		var firstImage = allImages[monsterIndex];
		var secondImage = allImages[monsterIndex];
		var correct_side = left_right[0];

		// Set one of the two images as plural (depends on both target audio plurality & whether correct image is left or right)
		if (singOrPlural == 'p'){
			isPlural = true;
			if (correct_side == true){
				firstImage = firstImage.substring(0,firstImage.length-4)+"p.png";
			} else {
				secondImage = secondImage.substring(0,secondImage.length-4)+"p.png";
			}
		} else {
			if (correct_side == true) {
				secondImage = secondImage.substring(0,secondImage.length-4)+"p.png";
			} else {
				firstImage = firstImage.substring(0,firstImage.length-4)+"p.png";
			}
		}

		experiments.push(forced_choice_trial_2(
			"/static/elise/img/images/" + firstImage,
			"/static/elise/img/images/" + secondImage,
			correct_side, 
			"/static/elise/sound/combinedsounds/" + allSounds[monsterIndex][singOrPlural],
			isPlural, monsterIndex, "number_round"));
	}


	for (var i = 0; i < 12; i++) {
		shuffle(left_right);
		var curr_trial = round_2_2AFC[i];
		var monsterIndex = parseInt(curr_trial[0]);
		var foilIndex = parseInt(curr_trial[2]);
		var singOrPlural = curr_trial[1];
		var isPlural = false;
		var firstImage = allImages[monsterIndex];
		var secondImage = allImages[foilIndex];
		var correct_side = left_right[0];

		if (correct_side == false){
			firstImage = allImages[foilIndex];
			secondImage = allImages[monsterIndex];
		}

		// Set one of the two images as plural (depends on both target audio plurality & whether correct image is left or right)
		if (singOrPlural == 'p'){
			isPlural = true;
			firstImage = firstImage.substring(0,firstImage.length-4)+"p.png";
			secondImage = secondImage.substring(0,secondImage.length-4)+"p.png";
		}

		experiments.push(forced_choice_trial_2(
			"/static/elise/img/images/" + firstImage,
			"/static/elise/img/images/" + secondImage,
			correct_side, 
			"/static/elise/sound/combinedsounds/" + allSounds[monsterIndex][singOrPlural],
			isPlural, monsterIndex, "neighborhood_round"));
	}

	experiments.push(playNextInstruction())
	experiments.push(audio_check_trial_2("/static/elise/sound/diamond_w.wav", "diamond"))
	experiments.push(playNextInstruction())

	// for the 4AFC trials, we need to randomly pick which 3 (of 6) / 6 (of 12) aliens in each sub-neighborhood will be singular in the noun round
	// so we will shuffle all four sub-neighborhoods and the first half will be sg for noun trial, plural for grammar trial; and vice versa

	// to do: redo how we pick sg/pl for each of these 4 subneighs

	index_list_big_train_pl = []
	for (var j = 0; j < 12; j++) {
		index_list_big_train_pl.push(j);
	}
	let big_train_plurals = []
	randind = (Math.floor(Math.random() * 12))
	randchoice = (index_list_big_train_pl.splice(randind, 1)[0])
	big_train_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 11))
	randchoice = (index_list_big_train_pl.splice(randind, 1)[0])
	big_train_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 10))
	randchoice = (index_list_big_train_pl.splice(randind, 1)[0])
	big_train_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 9))
	randchoice = (index_list_big_train_pl.splice(randind, 1)[0])
	big_train_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 8))
	randchoice = (index_list_big_train_pl.splice(randind, 1)[0])
	big_train_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 7))
	randchoice = (index_list_big_train_pl.splice(randind, 1)[0])
	big_train_plurals.push(randchoice);

	index_list_small_train_pl = []
	for (var j = 18; j < 24; j++) {
		index_list_small_train_pl.push(j);
	}
	let small_train_plurals = []
	randind = (Math.floor(Math.random() * 6))
	randchoice = (index_list_small_train_pl.splice(randind, 1)[0])
	small_train_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 5))
	randchoice = (index_list_small_train_pl.splice(randind, 1)[0])
	small_train_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 4))
	randchoice = (index_list_small_train_pl.splice(randind, 1)[0])
	small_train_plurals.push(randchoice);

	var all_plurals = big_train_plurals.concat(small_train_plurals);

	index_list_big_test_pl = []
	for (var j = 12; j < 18; j++) {
		index_list_big_test_pl.push(j);
	}
	let big_test_plurals = []
	randind = (Math.floor(Math.random() * 6))
	randchoice = (index_list_big_test_pl.splice(randind, 1)[0])
	big_test_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 5))
	randchoice = (index_list_big_test_pl.splice(randind, 1)[0])
	big_test_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 4))
	randchoice = (index_list_big_test_pl.splice(randind, 1)[0])
	big_test_plurals.push(randchoice);

	all_plurals = all_plurals.concat(big_test_plurals);

	index_list_small_test_pl = []
	for (var j = 24; j < 30; j++) {
		index_list_small_test_pl.push(j);
	}
	let small_test_plurals = []
	randind = (Math.floor(Math.random() * 6))
	randchoice = (index_list_small_test_pl.splice(randind, 1)[0])
	small_test_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 5))
	randchoice = (index_list_small_test_pl.splice(randind, 1)[0])
	small_test_plurals.push(randchoice);
	randind = (Math.floor(Math.random() * 4))
	randchoice = (index_list_small_test_pl.splice(randind, 1)[0])
	small_test_plurals.push(randchoice);

	all_plurals = all_plurals.concat(small_test_plurals);
	all_plurals = new Set(all_plurals);


	/// don't need some or all of this anymore (?)

	var big_train_only = [];
	for (var b = 0; b < 12; b++) {
		big_train_only.push(b);
	}

	var small_train_only = [];
	for (var s = 18; s < 24; s++) {
		small_train_only.push(s);
	}	
	
	var big_test_only = [];
	for (var b = 12; b < 18; b++) {
		big_test_only.push(b);
	}

	var small_test_only = [];
	for (var s = 24; s < 30; s++) {
		small_test_only.push(s);
	}	

	// for the grammar trials, we need to pick out foils from another subneighborhood, keeping test/train constant but changing big/small
	// for the trained neighborhoods first

	// we shuffle all 12 but are only going to use the first half out of the shuffle because small neighborhood trained only needs 6 foils
	var big_train_foil = [];
	for (var b = 0; b < 12; b++) {
		big_train_foil.push(b);
	}

	// we put each alien in their twice in order to have the 12 foils needed for the big trained neighborhood.
	var small_train_foil = [];
	for (var s = 18; s < 24; s++) {
		small_train_foil.push(s);
		small_train_foil.push(s);
	}	

	shuffle(big_train_foil);
	shuffle(small_train_foil);

	// for the test-only sub-neighborhoods, they've already served as each other's foils, so we will derange those arrays.
	// however, we cannot simply derange big/small_test_foil, because they were applied to a SHUFFLED array of targets... 

	var big_test_foil_2 = derange(big_test_foil);
	var small_test_foil_2 = derange(small_test_foil);

	var grammar_foil = small_train_foil.concat(small_test_foil_2);
	grammar_foil = grammar_foil.concat(big_train_foil.slice(0,6));
	grammar_foil = grammar_foil.concat(big_test_foil_2);



	var foil_big_train = tripleDerangement(big_train_only);
	var foil_small_train = tripleDerangement(small_train_only);
	var foil_big_test = tripleDerangement(big_test_only);
	var foil_small_test = tripleDerangement(small_test_only);

	var noun_foil_1 = foil_big_train[0].concat(foil_big_test[0]);
	noun_foil_1 = noun_foil_1.concat(foil_small_train[0]);
	noun_foil_1 = noun_foil_1.concat(foil_small_test[0]);

	var noun_foil_2 = foil_big_train[1].concat(foil_big_test[1]);
	noun_foil_2 = noun_foil_2.concat(foil_small_train[1]);
	noun_foil_2 = noun_foil_2.concat(foil_small_test[1]);

	var noun_foil_3 = foil_big_train[2].concat(foil_big_test[2]);
	noun_foil_3 = noun_foil_3.concat(foil_small_train[2]);
	noun_foil_3 = noun_foil_3.concat(foil_small_test[2]);

	var noun_4AFC = [];
	var grammar_4AFC = [];

	for (var k = 0; k < 30; k++){
		var alien = k;
		var grammar_foil_alien = grammar_foil[k];
		var noun_foil_1_alien = noun_foil_1[k];
		var noun_foil_2_alien = noun_foil_2[k];
		var noun_foil_3_alien = noun_foil_3[k];
		if (all_plurals.has(alien)) {
			grammar_4AFC.push([alien, "s", "g", grammar_foil_alien])
			noun_4AFC.push([alien, "p", "n", noun_foil_1_alien, noun_foil_2_alien, noun_foil_3_alien])
		} else {
			grammar_4AFC.push([alien, "p", "g", grammar_foil_alien])
			noun_4AFC.push([alien, "s", "n", noun_foil_1_alien, noun_foil_2_alien, noun_foil_3_alien])
		}
	}

	var all_4AFC = grammar_4AFC.concat(noun_4AFC);
	shuffle(all_4AFC);

	var four_positions = [1,2,3,4];
	for (var i = 0; i < 60; i++) {
		shuffle(four_positions);
		var curr_trial = all_4AFC[i];
		var monsterIndex = parseInt(curr_trial[0]);
		var trial_type = curr_trial[2];
		var singOrPlural = curr_trial[1];
		var isPlural = false;
		var foilIndex_1 = parseInt(curr_trial[3]);
		var target_image = allImages[monsterIndex];
		var subneigh = participant_data_array[monsterIndex][5]

		if (singOrPlural == 'p'){
			if (trial_type == 'g'){
				foil_image_1 = allImages[monsterIndex];
				foil_image_3 = allImages[foilIndex_1];
				foil_image_2 = foil_image_3.substring(0,foil_image_3.length-4)+"p.png";
			}
			target_image = target_image.substring(0,target_image.length-4)+"p.png";
			isPlural = true;
		} else {
			if (trial_type == 'g'){
				foil_image_1 = target_image.substring(0,target_image.length-4)+"p.png";
				foil_image_2 = allImages[foilIndex_1];
				foil_image_3 = foil_image_2.substring(0,foil_image_2.length-4)+"p.png";

			}
		}

		if (trial_type == 'n') {
			var foilIndex_2 = parseInt(curr_trial[4]);
			var foilIndex_3 = parseInt(curr_trial[5]);
			foil_image_1 = allImages[foilIndex_1];
			foil_image_2 = allImages[foilIndex_2];
			foil_image_3 = allImages[foilIndex_3];
			if (isPlural) {
				foil_image_1 = foil_image_1.substring(0,foil_image_1.length-4)+"p.png";
				foil_image_2 = foil_image_2.substring(0,foil_image_2.length-4)+"p.png";
				foil_image_3 = foil_image_3.substring(0,foil_image_3.length-4)+"p.png";
			}
		}

		var all_images = [target_image, foil_image_1, foil_image_2, foil_image_3];

		
		var firstImage = all_images[four_positions[0]-1];
		var secondImage = all_images[four_positions[1]-1];
		var thirdImage = all_images[four_positions[2]-1];
		var fourthImage = all_images[four_positions[3]-1];

		var correct_place = four_positions.indexOf(1)+1;


		experiments.push(forced_choice_trial_4(
			"/static/elise/img/images/" + firstImage,
			"/static/elise/img/images/" + secondImage,
			"/static/elise/img/images/" + thirdImage,
			"/static/elise/img/images/" + fourthImage,
			correct_place, 
			"/static/elise/sound/combinedsounds/" + allSounds[monsterIndex][singOrPlural],
			isPlural, monsterIndex, trial_type, subneigh));

		if (i == 14) {
			experiments.push(playNextInstruction())
			experiments.push(playNextInstruction())
			experiments.push(audio_check_trial_2("/static/elise/sound/island_w.wav", "island"))
			experiments.push(playNextInstruction())
		} else if (i == 29) {
			experiments.push(playNextInstruction())
			experiments.push(playNextInstruction())
			experiments.push(audio_check_trial_2("/static/elise/sound/engine_w.wav", "engine"))
			experiments.push(playNextInstruction())
		} else if (i == 44) {
			experiments.push(playNextInstruction())
			experiments.push(playNextInstruction())
			experiments.push(audio_check_trial_2("/static/elise/sound/printer_w.wav", "printer"))
			experiments.push(playNextInstruction())
		} else if (i == 59) {
			experiments.push(playNextInstruction())
			experiments.push(audio_check_trial_2("/static/elise/sound/airport_w.wav", "airport"))
		}
	
	}

	experiments.push(playNextInstruction())
	shuffle(EMlist);

	// three rounds of error monitoring trials // NOPE FOUR
	for (var i = 0; i < 3; i++) {
		round_list = EMlist[i];
		shuffle(round_list);
		// each round consists of 28 shuffled trials read in from the round-list
		for (var j = 0; j<28; j++) {
			var curr_trial = round_list[j];
			var monsterIndex = parseInt(curr_trial[0]);
			var errortype = curr_trial[2];
			var singOrPlural = curr_trial[1];
			var isPlural = false;
			var isGrammatical = false;
			var grammaticalSound = allSounds[monsterIndex][singOrPlural];
			var trialSound = grammaticalSound;
			var monsterNeighborhood = participant_data_array[monsterIndex][4];
			var subNeighborhood = participant_data_array[monsterIndex][5];

			if (singOrPlural == 'p') {
				isPlural = true;
			}

			if (errortype == '1') {
				// in this errortype, the determiner and suffix don't match in plurality
				// so, we grab the correct determiner for the plurality, and then make it the other plurality
				if (isPlural) {
					trialSound = grammaticalSound.substring(0,grammaticalSound.length-5)+"s.wav";
				} else {
					trialSound = grammaticalSound.substring(0,grammaticalSound.length-5)+"p.wav";
				}
			} else if (errortype == '2') {
				// in this errortype, the determiner is the correct plurality, but for the wrong neighborhood
				var foil_det;
				if (monsterNeighborhood == 'small') {
					if (isPlural) {
						foil_det = detLargePlur;
					} else {
						foil_det = detLargeSing;
					}
				} else {
					if (isPlural) {
						foil_det = detSmallPlur
					} else {
						foil_det = detSmallSing
					}
				}
				trialSound = "det" + foil_det + grammaticalSound.substring(4,grammaticalSound.length);
			} else if (errortype == '3') {
				trialSound = grammaticalSound.substring(0,grammaticalSound.length-5)+"_e" + grammaticalSound.substring(grammaticalSound.length-5,grammaticalSound.length);
			} else if (errortype == '0') {
				isGrammatical = true;
			}

			experiments.push(grammaticality_judgment_trial(isGrammatical, 
				"/static/elise/sound/combinedsounds/" + trialSound, 
				isPlural, monsterIndex, errortype, subNeighborhood))

			if (i == 0 && j == 20) {
				experiments.push(playNextInstruction())
				experiments.push(playNextInstruction())
				experiments.push(audio_check_trial_2("/static/elise/sound/shovel_w.wav", "shovel"))
				experiments.push(playNextInstruction())
			} else if (i == 1 && j == 13) {
				experiments.push(playNextInstruction())
				experiments.push(playNextInstruction())
				experiments.push(audio_check_trial_2("/static/elise/sound/armchair_w.wav", "armchair"))
				experiments.push(playNextInstruction())
			} else if (i == 2 && j == 7) {
				experiments.push(playNextInstruction())
				experiments.push(playNextInstruction())
				experiments.push(audio_check_trial_2("/static/elise/sound/trumpet_w.wav", "trumpet"))
				experiments.push(playNextInstruction())
			} else if (i == 2 && j == 27){
				experiments.push(playNextInstruction())
				experiments.push(audio_check_trial_2("/static/elise/sound/orange_w.wav", "orange"))
			}
			
			
		}
	}

	experiments.push(playNextInstruction())
	experiments.push(playNextInstruction())

	// the list for the production trials simply consists of every alien once pictured both plural and singular

	prod_test_list = []
	for (var j = 0; j < 30; j++) {
		alien_info = participant_data_array[j];
		anr = alien_info[0];
		img = alien_info[1];
		sound_s = alien_info[2];
		sound_p = alien_info[3];
		neigh = alien_info[4];
		subs = alien_info[5];
		prompt_s = getPrompt(sound_s);
		prompt_p = getPrompt(sound_p);
		singular_trial = [img, sound_s, prompt_s, false, anr, neigh, subs];
		plural_trial = [img, sound_p, prompt_p, true, anr, neigh, subs];
		prod_test_list.push(singular_trial);
		prod_test_list.push(plural_trial);
	}

	shuffle(prod_test_list);

	console.log(prod_test_list)

	for(var j = 0; j < 60; j++){
		trial_info = prod_test_list[j];
		experiments.push(production_test_trial("/static/elise/img/images/" + trial_info[0], 
			"/static/elise/sound/combinedsounds/" + trial_info[1], 
			trial_info[2], trial_info[3], trial_info[4], trial_info[5], trial_info[6]));
		
		if (j == 14) {
			experiments.push(playNextInstruction())
			experiments.push(playNextInstruction())
			experiments.push(audio_check_trial_2("/static/elise/sound/windmill_w.wav", "windmill"))
			experiments.push(playNextInstruction())
		} else if (j == 29) {
			experiments.push(playNextInstruction())
			experiments.push(playNextInstruction())
			experiments.push(audio_check_trial_2("/static/elise/sound/olive_w.wav", "olive"))
			experiments.push(playNextInstruction())
		} else if (j == 44) {
			experiments.push(playNextInstruction())
			experiments.push(playNextInstruction())
			experiments.push(audio_check_trial_2("/static/elise/sound/keyhole_w.wav", "keyhole"))
			experiments.push(playNextInstruction())
		} else if (j == 59) {
			experiments.push(playNextInstruction())
			experiments.push(audio_check_trial_3("/static/elise/sound/eggplant_w.wav", "eggplant"))
		}
}

	experiments.push(playNextInstruction())

	experiments.push(survey_trial("Please tell us anything you noticed about how the alien language and its grammar work."))
	experiments.push(survey_trial("You were one of the first participants to do this experiment, and we are still fine-tuning it before we collect the full data sample in Fall 2021. Please share any feedback about the experiment here! We will implement suggested changes later this summer, and really value any thoughts you want to share with us. "))


	experiments.push(playNextInstruction())
		
	// Returns matrix of experiment timelines
	return experiments;
}
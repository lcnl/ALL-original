
// Fisher-Yates shuffle algorithm https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
function shuffle(array) {
	var m = array.length, t, i;

	// While there remain elements to shuffle…
	while (m) {

		// Pick a remaining element…
		i = Math.floor(Math.random() * m--);

		// And swap it with the current element.
		t = array[m];
		array[m] = array[i];
		array[i] = t;
	}

	return array;
}

// Global for storing experiment sequence that is produced after reading in the experiment sequence
var trialData = " ";

// Takes info from CSV file and obtains experiment sequence that is encoded and returned as a 2D list
function processData(allText) {
	
	// Regex to split CSV format into 2D matrix 
	var allTextLines = allText.split(/\r\n|\n/);
	
	// Headers for each column that are stored as the first row in the matrix
	var headers = allTextLines[0].split(',');

    // Removes any blank headers 
	while (headers[headers.length - 1] == "") {
		headers.pop();
	}

	// Stores experiment lines 
	var lines = [];
	
	// Iterates through rows, each of which stores a list of experiment codes
	for (var i = 1; i < allTextLines.length; i++) {
		
		// splits comma separated experiment codes for current row
		var data = allTextLines[i].split(',');
		
		// Removes empty columns
		while (data[data.length - 1] == "") {
			data.pop();
		}
		
		// Checks to see that removing empty columns did not lead to an uneven row length. If this happens,
		// the CSV file is not properly formatted
		if (data.length == headers.length) {

			// Array storing the specific experiment codes from each string 
			var tarr = [];
			
			// Iterates through the experiment sequence for the current row
			for (var j = 0; j < data.length; j++) {
				
				// The experiment codes are stored in the format 'experimentnumberplurality' i.e. 12s means the 12th 
				// monster singular will be the stimulus
				var curr = data[j]
				
				// Pushes a tuple storing the monster number and plurality by splitting the string 
				tarr.push([curr.substring(0, curr.length - 1), curr.substring(curr.length - 1)]);
			}
			
			// Pushes to matrix
			lines.push(tarr);
		}
	}
	
	// Sets trialData global to the matrix generated by the method
	trialData = lines;
}

// Given an image number, outputs a string with the file name for that image
function imageFileName(imageNumber) {
	
	// Small images
	if (imageNumber < 12) {
		return "l" + imageNumber + 1 + ".png";
	}
	
	// Large images
	else {
		return "h" + imageNumber - 18 + 1 + ".png";
	}
}

// Given the determiner number, a boolean with true-> small, false-> big, a monster number and a boolean 
// with true->singular false->plural, outputs the file name for the associated sound file
function soundFileName(determiner, isSmall, monsterNumber, isSingular) {
	
	// Encodes determiner number
	var det = "det" + determiner + "_";
	var size;
	
	// Encodes size based on boolean value
	if (isSmall) {
		size = "small";
	}
	else {
		size = "big";
	}
	var plurality;
	
	// Encodes plurality based on boolean value
	if (isSingular) {
		plurality = "s";
	}
	else {
		plurality = "p";
	}
	
	// Concatenates all encodings as they appear in the file name
	return det + size + monsterNumber + plurality + ".wav";
}

// Generates an experiment timeline 
// TODO: Encode prompts as they appear in the experiments
function makeExp() {

	// Obtains boolean value 'comp' from URL which encodes whether the experiement will be production or comprehension
	const queryString = window.location.search;
	const urlParams = new URLSearchParams(queryString);
	const comp = urlParams.get('comp') == 'true';
	
	// Obtains big and small values from the dictionary storing their data
	// TODO: these will be changed to function calls to utility functions once they are written
	var bigValues = Object.values(big);
	var smallValues = Object.values(small);
	
	// Obtains the specific image and sound files for each of the big and small data files
	var bigImages = [];
	for (var i = 0; i < bigValues.length; i++) {
		bigImages.push(bigValues[i][0]);
	}
	var smallImages = [];
	for (var i = 0; i < smallValues.length; i++) {
		smallImages.push(smallValues[i][0]);
	}
	var bigSounds = [];
	for (var i = 0; i < bigValues.length; i++) {
		bigSounds.push(bigValues[i][1]);
	}
	var smallSounds = [];
	for (var i = 0; i < smallValues.length; i++) {
		smallSounds.push(smallValues[i][1]);
	}
	
	// Shuffles the big and small images
	shuffle(bigImages);
	shuffle(smallImages);
	shuffle(bigSounds);
	shuffle(smallSounds);
	
	// Concatenates images such that 0-17 are big, 18-29 small
	var allImages = bigImages.concat(smallImages);
	var allSounds = bigSounds.concat(smallSounds);
	
	// Shuffles the row sequences in trial data 
	shuffle(trialData);
	
	// Stores experiment timeline object
	experiments = []
	
	// Iterates through the rows in the trial data matrix
	for (var i = 0; i < trialData.length; i++) {
		
		// Current row
		curr = trialData[i];
		
		// Stores experiment block for this row
		block = [];
		
		// Shuffles the row itself
		shuffle(curr);
		
		// Iterates through the row, obtaining trial objects
		for (var j = 0; j < curr.length; j++) {
			
			// Obtains monster number and plurality from the parsed data
			var monsterIndex = parseInt(curr[j][0]);
			var singOrPlural = curr[j][1];
			
			// Calls functions to obtain trial objects and pushes them to the timeline
			// this part of the experiment contains passive comprehension trials
			block.push(passive_comprehension_trial(allImages[monsterIndex],
				allSounds[monsterIndex][singOrPlural], "Prompt"));
		}
		
		// Shuffles the row sequence once again
		shuffle(curr);
		
		// Comprehension trial
		if (comp) {
			
			// Same process as passive trial but generates active comprehension trial 
			for (var j = 0; j < curr.length; j++) {
				var monsterIndex = parseInt(curr[j][0]);
				var singOrPlural = curr[j][1];	
				block.push(active_comprehension_trial(
					allImages[monsterIndex],
					allSounds[monsterIndex][singOrPlural], "Prompt"));
			}
		} 
		// Production trial 
		else {
			for (var j = 0; j < curr.length; j++) {
				var monsterIndex = parseInt(curr[j][0]);
				var singOrPlural = curr[j][1];
				// What should the prompt be?
				block.push(active_production_trial(allImages[monsterIndex],
					allSounds[monsterIndex][singOrPlural], "Prompt"));
			}
		}
		// Pushes block of experiments to matrix
		experiments.push(block);
	}
	
	// Returns matrix of experiment timelines
	return experiments;
}